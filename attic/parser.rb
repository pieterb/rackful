# encoding: utf-8

# Required for parsing:
require_relative 'global.rb'

# Required for running:

module Rackful

# Base class for all concrete parsers defined in this library. You’ll probably
# want to use this class as the base class for your own parsers, too.
#
# This class mixes in module `StatusCodes` for convenience, as explained in the
# {StatusCodes StatusCodes documentation}.
# @abstract Subclasses must implement classmethod `::parse` with signature
#   `(void) parse( Request, Response, Resource )`
#   explained in {Resource::ClassMethods::add_parser}
# @example Subclassing this class
#   class MyTextParser < Rackful::Parser
#     parses 'text/*', 'application/xhtml+xml'
#     def self.parse request, response, resource
#       # YOUR CODE HERE...
#     end
#   end
class Parser
  include StatusCodes
  class << self
    # @api private
    def media_types
      @media_types ||= begin
        retval = rackful_parser_media_types
        if superclass.respond_to?(:media_types)
          retval += superclass.media_types
        end
        retval.uniq
      end
    end
    
    # @overload parses( media_type, ... )
    #   @param media_type [String]
    def parses *args
      rackful_parser_media_types.unshift(
        *( args.map { |mt| mt.to_s }.reverse )
      )
      rackful_parser_media_types.uniq!
      self
    end
    
    private
    def rackful_parser_media_types
      @rackful_parser_media_types ||= []
    end
  end # class << self # Rackful::Parser

end # class Rackful::Parser

# Parent class of all XML-parsing parsers.
# @abstract
# @since 0.2.0
class Parser::DOM < Parser

  # The media types parsed by this parser.
  # @see Parser
  parses 'text/xml', 'application/xml'


  def self.parse request, response, resource
    self.new(request).parse( response, resource )
  end

  # @return [Nokogiri::XML::Document]
  attr_reader :document
  attr_reader :request

  # @raise [HTTP400BadRequest] if the document is malformed.
  def initialize request
    @request = request
    # TODO Is ISO-8859-1 indeed the default encoding for XML documents? If so,
    # that fact must be documented and referenced.
    encoding = self.request.media_type_params['charset'] || 'ISO-8859-1'
    begin
      @document = Nokogiri.XML(
        self.request.env['rack.input'].read,
        self.request.canonical_uri.to_s,
        encoding
      ) do |config|
        config.strict.nonet
      end
    rescue
      raise HTTP400BadRequest, $!.to_s
    end
    raise( HTTP400BadRequest, $!.to_s ) unless @document.root
  end
  
end # class Rackful::Parser::DOM




# Parses XHTML as generated by {Representation::XHTML}.
class Parser::XHTML < Parser::DOM


  # The media types parsed by this parser.
  # @see Parser::parses
  parses 'text/xml', 'application/xml', 'application/xhtml+xml', 'text/html'


  # @see Parser#parse
  def parse response, resource
    # Try to find the actual content:
    content = self.document.root.xpath(
      '//html:div[@id="rackful-content"]',
      'html' => 'http://www.w3.org/1999/xhtml'
    )
    # There must be exactly one element <div id="rackful_content"/> in the document:
    if content.empty?
      raise HTTP400BadRequest, 'Couldn’t find div#rackful-content in request body.'
    end
    if content.length > 1
      raise HTTP400BadRequest, 'Multiple instances of div#rackful-content found in request body.'
    end
    # Initialize @base_url:
    base_url = self.document.root.xpath(
      '/html:html/html:head/html:base',
      'html' => 'http://www.w3.org/1999/xhtml'
    )
    if base_url.empty?
      @base_url = self.request.canonical_uri.dup
    else
      @base_url = URI( base_url.first.attribute('href').text ).normalize
      if @base_url.relative?
        @base_url = self.request.canonical_uri + @base_url
      end
    end
    # Parse the f*cking thing:
    resource.to_rackful = self.parse_recursive content.first
  end


  # @api private
  def parse_recursive node

    # A URI:
    if ( nodelist = node.xpath( 'html:a', 'html' => 'http://www.w3.org/1999/xhtml' ) ).length == 1
      r = URI( nodelist.first.attribute('href').text )
      r.relative? ? @base_url + r : r

    # An Object (AKA a Hash)
    elsif ( nodelist = node.xpath( 'html:dl', 'html' => 'http://www.w3.org/1999/xhtml' ) ).length == 1
      self.parse_object nodelist.first

    # A list of Objects with identical keys:
    elsif ( nodelist = node.xpath( 'html:table', 'html' => 'http://www.w3.org/1999/xhtml' ) ).length == 1
      self.parse_object_list nodelist.first

    # A list of things (AKA an Array):
    elsif ( nodelist = node.xpath( 'html:ul', 'html' => 'http://www.w3.org/1999/xhtml' ) ).length == 1
      nodelist.first.xpath(
        'html:li',
        'html' => 'http://www.w3.org/1999/xhtml'
      ).collect do |n| self.parse_recursive n end

    # A simple type:
    elsif type = node.attribute_with_ns( 'type', 'http://www.w3.org/2001/XMLSchema' )
      prefix, typename = type.text.split(':', 2)
      unless typename && 'http://www.w3.org/2001/XMLSchema' == node.namespaces["xmlns:#{prefix}"]
        raise HTTP400BadRequest, "Unknown XML Schema type: #{type}"
      end
      self.parse_simple_type node, typename
    else
      raise HTTP400BadRequest, 'Can’t parse:<br/>' + Rack::Utils.escape_html(node.to_xml)
    end
  end


  # @api private
  def parse_simple_type node, typename
    case typename
    when 'boolean'
      case node.inner_text.strip
      when 'true'  then true
      when 'false' then false
      else nil
      end
    when 'integer'
      node.inner_text.strip.to_i
    when 'numeric'
      node.inner_text.strip.to_f
    when 'dateTime'
      Time.xmlschema(node.inner_text.strip)
    when 'base64Binary'
      Base64.decode64(node.inner_text)
    when 'string'
      node.inner_text
    else
      raise HTTP400BadRequest, "Unknown XML Schema type: #{type}"
    end
  end


  # @api private
  def parse_object node
    current_property = nil
    r = {}
    node.children.each do |child|
      if 'dt' == child.name &&
         'http://www.w3.org/1999/xhtml' == child.namespace.href
        if current_property
          raise HTTP400BadRequest, 'Can’t parse:<br/>' + Rack::Utils.escape_html(node.to_xml)
        end
        current_property = child.inner_text.strip.split(' ').join('_').to_sym
      elsif 'dd' == child.name &&
            'http://www.w3.org/1999/xhtml' == child.namespace.href
        unless current_property
          raise HTTP400BadRequest, 'Can’t parse:<br/>' + Rack::Utils.escape_html(node.to_xml)
        end
        r[current_property] = self.parse_recursive( child )
        current_property = nil
      end
    end
    r
  end


  # @api private
  def parse_object_list node
    properties = node.xpath(
      'html:thead/html:tr/html:th',
      'html' => 'http://www.w3.org/1999/xhtml'
    ).collect do |th|
      th.inner_text.strip.split(' ').join('_').to_sym
    end
    if properties.empty?
      raise HTTP400BadRequest, 'Can’t parse:<br/>' + Rack::Utils.escape_html(node.to_xml)
    end
    n = properties.length
    node.xpath(
      'html:tbody/html:tr',
      'html' => 'http://www.w3.org/1999/xhtml'
    ).collect do |row|
      values = row.xpath(
        'html:td', 'html' => 'http://www.w3.org/1999/xhtml'
      )
      unless values.length == n
        raise HTTP400BadRequest, 'Can’t parse:<br/>' + Rack::Utils.escape_html(row.to_xml)
      end
      object = {}
      Range.new(0,n-1).each do |i|
        object[properties[i]] = self.parse_recursive( values[i] )
      end
      object
    end
  end


end # class Parser::XHTML


class Parser::JSON < Parser


  parses 'application/json', 'application/x-json'

  def self.parse request, response, resource
    r = ::JSON.parse(
      request.env['rack.input'].read,
      :symbolize_names => true
    )
    resource.to_rackful = self.recursive_datetime_parser r
  end


  def self.recursive_datetime_parser p
    if p.kind_of?(String)
      begin
        return Time.xmlschema(p)
      rescue
      end
    elsif p.kind_of?(Hash)
      p.keys.each do
        |key|
        p[key] = recursive_datetime_parser( p[key] )
      end
    elsif p.kind_of?(Array)
      (0 ... p.size).each do
        |i|
        p[i] = recursive_datetime_parser( p[i] )
      end
    end
    p
  end


end # class Parser::JSON
end # module Rackful
